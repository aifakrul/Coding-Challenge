# -*- coding: utf-8 -*-
"""Coding Challenge.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1e3toRdQcVLp14m15po43K9TmdZ66G9oY

Author
#MD Fakrul Islam
#fakruldsebd@gmail.com
#https://www.linkedin.com/in/fakrul-islam-bd/
#https://github.com/aifakrul
#1-641-233-2418
#Reference
#https://en.wikipedia.org/wiki/Needleman%E2%80%93Wunsch_algorithm
#https://en.wikipedia.org/wiki/Smith%E2%80%93Waterman_algorithm
#https://en.wikipedia.org/wiki/Longest_common_subsequence_problem
"""

def printMatrix(seq1, seq2, matrix):
    sep = '\t|\t'
    print(*[' ', 'j', *seq1], sep=sep)
    rowStart = ['i', *seq2]
    for i in range(len(matrix)):
        print(rowStart[i], end=sep)
        print(*matrix[i], sep=sep)

def printTraceback(tracebback):
    print('Traceback:')
    for i, sol in enumerate(tracebback):
        print(f'\t#{i+1}')
        print(f'\t\tSequence 1: {sol[0]}')
        print(f'\t\tSequence 2: {sol[1]}')

def getSimilarity(seg1, seg2):
    count = 0
    for i in range(len(seg1)):
        count += int(seg1[i] == seg2[i])
    return count

def addToAll(array, v1, v2):
    for item in array:
        item[0] += v1
        item[1] += v2
    return array

def initMatrix(seq1Length, seq2Length, gapPenalty):
    matrix = [[]]
    for i in range(seq1Length+1):
        matrix[0].append(i * gapPenalty)
    for i in range(1, seq2Length+1):
        matrix.append([i * gapPenalty] + [0 for i in range(seq1Length)])
    return matrix

def getTraceback(matrix, i, j, seq1, seq2):
    solutions = []
    if matrix[j][i] == 0:
        solutions.append(['', ''])
        return solutions

    if seq1[i-1] == seq2[j-1]:
        branchSolutions = getTraceback(matrix, i-1, j-1, seq1, seq2)
        addToAll(branchSolutions, seq1[i-1], seq1[i-1])
        solutions += branchSolutions
    else:
        maxValue = max(matrix[j-1][i-1], matrix[j-1][i], matrix[j][i-1])
        if matrix[j-1][i-1] == maxValue:
            branchSolutions = getTraceback(matrix, i-1, j-1, seq1, seq2)
            addToAll(branchSolutions, seq1[i-1], seq2[j-1])
            solutions += branchSolutions
        if matrix[j][i-1] == maxValue:
            branchSolutions = getTraceback(matrix, i-1, j, seq1, seq2)
            addToAll(branchSolutions, seq1[i-1], '_')
            solutions += branchSolutions
        if matrix[j-1][i] == maxValue:
            branchSolutions = getTraceback(matrix, i, j-1, seq1, seq2)
            addToAll(branchSolutions, '_', seq2[j-1])
            solutions += branchSolutions

    return solutions

def lcs(X , Y):
	# find the length of the strings
	m = len(X)
	n = len(Y)

	# declaring the array for storing the dp values
	L = [[None]*(n+1) for i in range(m+1)]

	for i in range(m+1):
		for j in range(n+1):
			if i == 0 or j == 0 :
				L[i][j] = 0
			elif X[i-1] == Y[j-1]:
				L[i][j] = L[i-1][j-1]+1
			else:
				L[i][j] = max(L[i-1][j] , L[i][j-1])

	# L[m][n] contains the length of LCS of X[0..n-1] & Y[0..m-1]
	return L[m][n]
#end of function lcs

def DotMatrixWindowScoring(windowSize, step, threshold, seq1, seq2):
    output = [[' '] * len(seq1) for _ in range(len(seq2))]
    for j in range(0, len(seq2) - windowSize+1, step):
        for i in range(0, len(seq1) - windowSize+1, step):
            if getSimilarity(seq1[i: i+windowSize], seq2[j: j+windowSize]) >= threshold:
                output[j + (windowSize//2)][i + (windowSize//2)] = 'x'
    print(*[' ', *seq1], sep='|')
    for i in range(len(output)):
        print(seq2[i] + '|', end='')
        print(*output[i], sep='|')

def needlemanWunch(gapPenalty, match, misMatch, seq1, seq2):
    matrix = initMatrix(len(seq1), len(seq2), gapPenalty)

    for j in range(1, len(seq1)+1):
        for i in range(1, len(seq2)+1):
            matrix[i][j] = max(matrix[i-1][j-1] + (match if seq1[j-1] == seq2[i-1] else misMatch),
                               matrix[i-1][j]+gapPenalty, matrix[i][j-1]+gapPenalty)

    printMatrix(seq1, seq2, matrix)
    print()
    printTraceback(getTraceback(
        matrix, len(seq1), len(seq2), seq1, seq2))

def smithwaterman(gapPenalty, match, misMatch, seq1, seq2):
    matrix = [[0] * (len(seq1)+1) for _ in range(len(seq2)+1)]

    maxValue, maxI, MaxJ = 0, 0, 0
    for j in range(1, len(seq1)+1):
        for i in range(1, len(seq2)+1):
            currentValue = max(matrix[i-1][j-1] + (match if seq1[j-1] == seq2[i-1] else misMatch),
                               matrix[i-1][j] +
                               gapPenalty, matrix[i][j-1]+gapPenalty,
                               0)
            if currentValue >= maxValue:
                maxValue = currentValue
                maxI, MaxJ = j, i
            matrix[i][j] = currentValue

    printMatrix(seq1, seq2, matrix)
    print()
    printTraceback(getTraceback(matrix, maxI, MaxJ, seq1, seq2))

if __name__ == "__main__":
    DotMatrixWindowScoring(windowSize=9,
                           step=3,
                           threshold=4,
                           seq1="ACCTTGTCCTCTTTGCCC",
                           seq2="ACGTTGACCTGTAACCTC"
                           )

needlemanWunch(
        gapPenalty=-1,
        match=2,
        misMatch=-1,
        seq1="ACGCTG",
        seq2="CATGT"
    )

smithwaterman(
        gapPenalty=-6,
        match=5,
        misMatch=-2,
        seq1="TGCTCGTA",
        seq2="TTCATA"
    )

# Driver program to test the above function
X = "AGGTAB"
Y = "GXTXAYB"
print ("Length of LCS is ", lcs(X, Y) )